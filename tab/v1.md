# Tab Protocol (Tab v1)

Tab is the bidirectional protocol between client compositors and Shift for authentication, DMA-BUF framebuffer linking, per-frame fence commits, receiving routed input events, and driving session orchestration such as admin-controlled switches. This document walks through the full lifecycle—from the initial socket connection to high-FPS multi-monitor rendering—so implementors can confidently integrate with Shift using Tab v1.

## Tab Messages

All Tab messages are framed as **two UTF-8 lines** on a persistent Unix domain socket connection:

1. **Header line** – ASCII identifier naming the event type (e.g. `hello`, `swap_buffers`).
2. **Payload line** – Either a JSON object, a raw string, or the sentinel `\0\0\0\0` to indicate no payload.

All messages *always* contain two lines — even messages without a payload. Payload-less messages simply set the second line to the four-byte sentinel.

File descriptors (FDs) ride along the same `sendmsg` call via `SCM_RIGHTS`. Each header defines how many FDs (if any) must accompany it.

Example JSON message:

```
auth
{"token":"adm_xVJbVARh0/XFVYJBZiRQWhotDWo="}
```

Example raw-string message:

```
swap_buffers
mon_aNwVCYV9h1EFs4tON1jgtca3ycY= 0
```

## Connections

Every compositor opens a single `AF_UNIX` `SOCK_SEQPACKET` connection to `/tmp/shift.sock` and keeps it alive for the compositor’s lifetime. The socket carries both directions of traffic — Shift may send messages at any time (monitor hotplug, input, session updates, errors).

### Connection Lifecycle

1. Connect to `/tmp/shift.sock`.
2. Receive `hello` from Shift.
3. Send `auth` with the compositor’s token.
4. Receive `auth_ok` or `auth_error`.
5. Admin clients may create sessions with `session_create` and receive tokens via `session_created`.
6. After `auth_ok`, clients track monitor topology and session state.
7. Session-role clients send `session_ready` when their desktop environment finishes initialization.
8. For each monitor assigned to this session, send `framebuffer_link` with **two DMA-BUF FDs** for double-buffering.
9. Begin the frame loop: render → `swap_buffers` → wait for `frame_done` → repeat.
10. Handle async events: `input_event`, `monitor_added`, `monitor_removed`, `session_state`, `session_active`.
11. On disconnect or error, release resources and reconnect if appropriate.

## Hello (hello)

**Direction:** Shift → Client
**Header:** `hello`
**Payload:** JSON

```ts
type HelloPayload = {
    server: string,
    protocol: string,
};
```

Shift announces itself and the supported Tab protocol version. Clients must validate compatibility.

Example:

```
hello
{"server":"Shift v0.1.0-alpha","protocol":"tab/v1.0.0"}
```

## Authentication (auth, auth_ok, auth_error)

### auth

**Direction:** Client → Shift

```ts
type AuthPayload = { token: string };
```

### auth_ok

**Direction:** Shift → Client

Returns session metadata and the current monitor list.

```ts
type AuthOkPayload = {
    session: SessionInfo,
    monitors: MonitorInfo[],
};
```

### Common Types

```ts
type MonitorInfo = {
    id: string,
    width: number,
    height: number,
    refresh_rate: number,
    name: string,
};

type SessionInfo = {
    id: string,
    role: SessionRole,
    display_name?: string | null,
    state: SessionLifecycle,
};

type SessionLifecycle = 'pending' | 'loading' | 'occupied' | 'consumed';
type SessionRole = 'admin' | 'session';
```

### auth_error

Sent when authentication fails. Shift closes the socket immediately afterward.

```ts
type AuthErrorPayload = { error: string };
```

## Framebuffer Linking (framebuffer_link)

- **Direction:** Client → Shift
- **Header:** `framebuffer_link`
- **Payload:** JSON
- **FDs:** **Exactly 2 DMA-BUF FDs**, in order: **buffer 0**, then **buffer 1**.

This message establishes a double-buffered scanout path for a monitor. Both DMA-BUFs must have identical geometry and format.

```ts
type FramebufferLinkPayload = {
    monitor_id: string,
    width: number,
    height: number,
    stride: number,
    offset: number,
    fourcc: number,
};
```

### Initial Buffer State

After `framebuffer_link`, Shift does **not** select a front buffer:

```
front_buffer = None
```

Shift draws nothing until the compositor performs its **first** `swap_buffers`.

Clients must resend `framebuffer_link` whenever reallocating buffers or changing format/resolution.

## Frame Loop (swap_buffers, frame_done)

### swap_buffers

- **Direction:** Client → Shift
- **Header:** `swap_buffers`
- **Payload:** `<monitor_id> <buffer_index>`
- **FDs:** **None** (client must wait for its own GPU fence before calling `swap_buffers`)

The compositor renders into one buffer, waits for its GPU fence locally, then requests Shift to flip that buffer to the screen. Shift no longer waits on a fence FD—synchronization is completely the client’s responsibility.

After sending `swap_buffers`, the compositor must **lock that buffer locally** and must not render into it again until receiving the matching `frame_done`.

### frame_done

- **Direction:** Shift → Client
- **Header:** `frame_done`
- **Payload:** `<monitor_id> <buffer_index>`

Sent for each completed swap. This indicates that the buffer has finished scanning out and may be unlocked for reuse.

### Frame Loop Summary

1. Render into an unlocked buffer.
2. Wait for the GPU fence on that buffer to signal.
3. Send `swap_buffers <monitor_id> <buffer_index>`.
4. Lock that buffer (it is now pending scan-out).
5. Wait for `frame_done` for the previously submitted buffer.
6. Unlock the previous buffer.
7. Repeat.

This models classic double-buffering behavior.

### Inactive Sessions

When a session becomes inactive:

1. Shift completes **one final** pending swap if any.
2. Shift **stops sending `frame_done`** for the session.

The compositor remains alive but naturally pauses rendering due to lack of `frame_done` events.

When the session becomes active again, normal behavior resumes.

## Monitor Management (monitor_added, monitor_removed)

### monitor_added

Announces new monitors.

```ts
type MonitorAddedPayload = { monitor: MonitorInfo };
```

### monitor_removed

Announces monitor removal.

```ts
type MonitorRemovedPayload = {
    monitor_id: string,
    name: string,
};
```

## Input Events (input_event)

Shift only forwards input to the **active session**. The payload matches libinput semantics and consists of a discriminated union of all input event types.

```ts

type InputEventPayload =
    | PointerMotionEvent
    | PointerMotionAbsoluteEvent
    | PointerButtonEvent
    | PointerAxisEvent
    | KeyEvent
    | TouchDownEvent
    | TouchUpEvent
    | TouchMotionEvent
    | TouchFrameEvent
    | TouchCancelEvent
    | TableToolProximityEvent
    | TabletToolAxisEvent
    | TabletToolTipEvent
    | TabletToolButtonEvent
    | TablePadButtonEvent
    | TablePadRingEvent
    | TablePadStripEvent
    | SwitchToggleEvent
    | GestureSwipeBeginEvent
    | GestureSwipeUpdateEvent
    | GestureSwipeEndEvent
    | GesturePinchBeginEvent
    | GesturePinchUpdateEvent
    | GesturePinchEndEvent
    | GestureHoldBeginEvent
    | GestureHoldEndEvent;

// ======================
// Pointer
// ======================

type PointerMotionEvent = {
    kind: 'pointer_motion',
    device: number,
    time_usec: number,
    x: number,
    y: number,
    dx: number,
    dy: number,
    unaccel_dx: number,
    unaccel_dy: number,
};

type PointerMotionAbsoluteEvent = {
    kind: 'pointer_motion_absolute',
    device: number,
    time_usec: number,
    x: number,
    y: number,
    x_transformed: number,
    y_transformed: number,
};

type PointerButtonEvent = {
    kind: 'pointer_button',
    device: number,
    time_usec: number,
    button: number,
    state: ButtonState,
};

type PointerAxisEvent = {
    kind: 'pointer_axis',
    device: number,
    time_usec: number,
    orientation: AxisOrientation,
    delta: number,
    delta_discrete: number | null,
    source: AxisSource,
};

// ======================
// Keyboard
// ======================

type KeyEvent = {
    kind: 'key',
    device: number,
    time_usec: number,
    key: number,
    state: KeyState,
};

// ======================
// Touch
// ======================

type TouchDownEvent = {
    kind: 'touch_down',
    device: number,
    time_usec: number,
    contact: TouchContact,
};

type TouchUpEvent = {
    kind: 'touch_up',
    device: number,
    time_usec: number,
    contact_id: number,
};

type TouchMotionEvent = {
    kind: 'touch_motion',
    device: number,
    time_usec: number,
    contact: TouchContact,
};

type TouchFrameEvent = {
    kind: 'touch_frame',
    time_usec: number,
};

type TouchCancelEvent = {
    kind: 'touch_cancel',
    time_usec: number,
};

// ======================
// Tablet tool
// ======================

type TableToolProximityEvent = {
    kind: 'table_tool_proximity',
    device: number,
    time_usec: number,
    in_proximity: boolean,
    tool: TabletTool,
};

type TabletToolAxisEvent = {
    kind: 'tablet_tool_axis',
    device: number,
    time_usec: number,
    tool: TabletTool,
    axes: TabletToolAxes,
};

type TabletToolTipEvent = {
    kind: 'tablet_tool_tip',
    device: number,
    time_usec: number,
    tool: TabletTool,
    state: TipState,
};

type TabletToolButtonEvent = {
    kind: 'tablet_tool_button',
    device: number,
    time_usec: number,
    tool: TabletTool,
    button: number,
    state: ButtonState,
};

// ======================
// Tablet pad
// ======================

type TablePadButtonEvent = {
    kind: 'table_pad_button',
    device: number,
    time_usec: number,
    button: number,
    state: ButtonState,
};

type TablePadRingEvent = {
    kind: 'table_pad_ring',
    device: number,
    time_usec: number,
    ring: number,
    position: number,
    source: AxisSource,
};

type TablePadStripEvent = {
    kind: 'table_pad_strip',
    device: number,
    time_usec: number,
    strip: number,
    position: number,
    source: AxisSource,
};

// ======================
// Switch
// ======================

type SwitchToggleEvent = {
    kind: 'switch_toggle',
    device: number,
    time_usec: number,
    switch: SwitchType,
    state: SwitchState,
};

// ======================
// Gestures
// ======================

type GestureSwipeBeginEvent = {
    kind: 'gesture_swipe_begin',
    device: number,
    time_usec: number,
    fingers: number,
};

type GestureSwipeUpdateEvent = {
    kind: 'gesture_swipe_update',
    device: number,
    time_usec: number,
    fingers: number,
    dx: number,
    dy: number,
};

type GestureSwipeEndEvent = {
    kind: 'gesture_swipe_end',
    device: number,
    time_usec: number,
    cancelled: boolean,
};

type GesturePinchBeginEvent = {
    kind: 'gesture_pinch_begin',
    device: number,
    time_usec: number,
    fingers: number,
};

type GesturePinchUpdateEvent = {
    kind: 'gesture_pinch_update',
    device: number,
    time_usec: number,
    fingers: number,
    dx: number,
    dy: number,
    scale: number,
    rotation: number,
};

type GesturePinchEndEvent = {
    kind: 'gesture_pinch_end',
    device: number,
    time_usec: number,
    cancelled: boolean,
};

type GestureHoldBeginEvent = {
    kind: 'gesture_hold_begin',
    device: number,
    time_usec: number,
    fingers: number,
};

type GestureHoldEndEvent = {
    kind: 'gesture_hold_end',
    device: number,
    time_usec: number,
    cancelled: boolean,
};

// ======================
// Shared types
// ======================

type ButtonState = 'pressed' | 'released';
type KeyState = 'pressed' | 'released';
type TipState = 'down' | 'up';

type AxisOrientation = 'vertical' | 'horizontal';
type AxisSource = 'wheel' | 'finger' | 'continuous' | 'wheel_tilt';

type SwitchType = 'lid' | 'tablet_mode';
type SwitchState = 'on' | 'off';

type TouchContact = {
    id: number,
    x: number,
    y: number,
    x_transformed: number,
    y_transformed: number,
};

type TabletTool = {
    serial: number,
    tool_type: TabletToolType,
    capability: TabletToolCapability,
};

type TabletToolType =
    | 'pen'
    | 'eraser'
    | 'brush'
    | 'pencil'
    | 'airbrush'
    | 'finger'
    | 'mouse'
    | 'lens';

type TabletToolCapability = {
    pressure: boolean,
    distance: boolean,
    tilt: boolean,
    rotation: boolean,
    slider: boolean,
    wheel: boolean,
};

type TabletToolAxes = {
    x: number,
    y: number,
    pressure: number | null,
    distance: number | null,
    tilt_x: number | null,
    tilt_y: number | null,
    rotation: number | null,
    slider: number | null,
    wheel_delta: number | null,
    buttons: number[],
};

```

Shift forwards libinput-like events only to the active session. The payload is a discriminated union of all input event kinds.

## Session Management (session_create, session_created, session_ready, session_state)

Tab supports a lightweight session lifecycle model. Admin clients (e.g. login shells) create sessions, launch compositors bound to them, and monitor their lifecycle transitions.

### session_create

- **Direction:** Admin Client → Shift
- **Header:** `session_create`
- **Payload:** JSON

Requests the creation of a new session placeholder. Shift allocates internal resources and returns a single-use authentication token.

```ts

type SessionCreatePayload = {
	role: SessionRole,           // 'session' or 'admin'
	display_name?: string | null // Optional human-readable name
};

```

Example:
```

session_create
{"role":"session","display_name":"alice"}

```

### session_created

- **Direction:** Shift → Admin Client
- **Header:** `session_created`

Returns the new session descriptor plus the token the compositor must authenticate with.

```ts

type SessionCreatedPayload = {
session: SessionInfo,
token: string,
};

```

Example:
```

session_created
{"session":{"id":"se_user2","role":"session","state":"pending"},"token":"ses_QneY60mnZsYt2c9RgK+1CA=="}

```

### session_ready

**Direction:** Session Client → Shift
**Header:** `session_ready`

The compositor sends this when it has completed all initialization (DBus, portals, UI environment). Before this, the session is considered `loading` and Shift will not switch to it.

```ts

type SessionReadyPayload = {
	session_id: string,
};

```

Example:
```

session_ready
{"session_id":"se_user2"}

```

### session_state

**Direction:** Shift → Admin Client
**Header:** `session_state`

Shift broadcasts this event whenever a session transitions between lifecycle states:

```

pending → loading → occupied → consumed

```

`pending`: Token created, compositor not connected.
`loading`: Compositor authenticated but not ready.
`occupied`: Session is ready and may be foregrounded.
`consumed`: Session is finalized and may not be reused.

```ts

type SessionStatePayload = {
	session: SessionInfo,
};

```

Example:
```

session_state
{"session":{"id":"se_user2","role":"session","display_name":"alice","state":"occupied"}}

```

## Session Control (session_switch, session_active)

Admin clients request active session changes. Shift notifies all clients when the active session changes.

### session_switch

**Direction:** Admin Client → Shift
**Header:** `session_switch`
**Payload:** JSON

```ts
type SessionSwitchPayload = {
    session_id: string,
    animation?: string | null,
    duration: number, // seconds
};
```

### session_active

**Direction:** Shift → Client
**Header:** `session_active`
**Payload:** JSON

```ts
type SessionActivePayload = { session_id: string };
```

## Keepalive (ping, pong)

Ping-pong messages allow simple heartbeat checks. Payload is always `\0\0\0\0`.

## Errors (error)

Shift uses the `error` header for recoverable issues such as malformed payloads or invalid buffer FDs.

```ts
type ErrorPayload = {
    code: string,
    message?: string | null,
};
```

Representative codes:
- `unknown_monitor`
- `invalid_texture_fd`
- `protocol_violation`
- `inactive_session`
- `forbidden`
- `invalid_state`
