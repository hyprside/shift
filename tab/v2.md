# Tab Protocol (Tab v2)

Tab v2 uses explicit buffer ownership transfer between compositor clients and Shift.

This file documents the **implemented** v2 behavior.

## Framing

Messages use the same framing as v1:

1. Header line (`ascii`)
2. Payload line (raw string / JSON / `\0\0\0\0`)

FDs are sent with `SCM_RIGHTS` in the same packet.

## Ownership Model

For each `(session_id, monitor_id, buffer_index)` ownership is either:

- `client` (compositor may write/render)
- `shift` (Shift may read/sample/scanout)

Rule: previous owner must not touch the buffer until it is released back.

## Initial State

After `framebuffer_link` (2 dma-buf FDs), both buffers start as client-owned.

## v2 Synchronization Messages

## `buffer_request`

- Direction: `client -> shift`
- Payload: raw string: `<monitor_id> <0|1>`
- FDs: optional `0 or 1`
  - if present, FD is an acquire fence for this buffer request

Meaning:

- client requests transfer of that buffer to Shift
- Shift forwards to rendering layer
- rendering layer validates and reacts

## `buffer_request_ack`

- Direction: `shift -> client`
- Payload: raw string: `<monitor_id> <0|1>`
- FDs: none

Meaning:

- rendering layer accepted request and updated internal state
- ownership transfers to Shift at this point

## `buffer_release`

- Direction: `shift -> client`
- Payload: raw string: `<monitor_id> <0|1>`
- FDs: none

Meaning:

- Shift finished consuming that previously-owned client buffer
- ownership transfers back to client

## `error`

- Direction: `shift -> client`
- Payload: JSON `{ code: string, message?: string }`

Used for protocol/ownership violations and renderer rejection.

## Fence FD Semantics

If `buffer_request` carries an acquire fence FD:

1. ownership still transfers on `buffer_request_ack`
2. rendering layer must not sample/use that slot until the fence is signaled
3. Shift keeps last valid current buffer until pending buffer fence is ready

This avoids reading unfinished compositor writes while avoiding visual stalls.

## Request/Ack/Release Lifecycle

Typical frame flow:

1. Client acquires a free buffer (client-owned) and renders.
2. Client sends `buffer_request <monitor_id> <buffer>` (+ optional fence FD).
3. Shift server records request as pending and forwards to renderer.
4. Renderer:
   - accepts: stores pending slot/fence, emits ack event
   - rejects: emits reject event
5. On accept:
   - Shift sends `buffer_request_ack`
   - ownership becomes `shift`
6. Renderer consumes buffer when fence allows, composes/presents.
7. On later pageflip bookkeeping, Shift sends `buffer_release` for previous front.
8. ownership becomes `client` again.

## Multi-Monitor / Multi-Session Notes

State is tracked per `(session, monitor, buffer)`, so requests/releases are independent per monitor.
During transitions, multiple sessions can have concurrent pending slots/fences.

## Compatibility

v2 is not backward compatible with v1 sync messages.

- v2 data path uses:
  - `buffer_request`
  - `buffer_request_ack`
  - `buffer_release`
- `swap_buffers` / `frame_done` are not part of v2.

## Minimal v2 Header Set

- Existing control headers:
  - `hello`, `auth`, `auth_ok`, `auth_error`
  - `framebuffer_link`
  - monitor/session/input/error/ping/pong headers
- v2 sync headers:
  - `buffer_request`
  - `buffer_request_ack`
  - `buffer_release`
